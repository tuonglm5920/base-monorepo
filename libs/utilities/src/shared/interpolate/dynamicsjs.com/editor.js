// Generated by CoffeeScript 1.7.1
(function() {
  var Editor, UIGraph, UIProperty, UISlider, merge, roundf,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  roundf = function(float, decimals) {
    var factor;
    factor = Math.pow(10, decimals);
    return Math.round(float * factor) / factor;
  };

  merge = function(a, b) {
    var c, k, v;
    c = {};
    for (k in a) {
      v = a[k];
      c[k] = v;
    }
    for (k in b) {
      v = b[k];
      c[k] = v;
    }
    return c;
  };

  UIGraph = (function() {
    function UIGraph(canvas) {
      this.insertPoint = __bind(this.insertPoint, this);
      this.canvasKeyUp = __bind(this.canvasKeyUp, this);
      this.canvasMouseUp = __bind(this.canvasMouseUp, this);
      this.canvasMouseMove = __bind(this.canvasMouseMove, this);
      this.canvasMouseDown = __bind(this.canvasMouseDown, this);
      this.pointFromLocation = __bind(this.pointFromLocation, this);
      this.isLocationAroundCenter = __bind(this.isLocationAroundCenter, this);
      this.locationFromEvent = __bind(this.locationFromEvent, this);
      this.draw = __bind(this.draw, this);
      this.points = null;
      this.curve = null;
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.editable = false;
      this.r = window.devicePixelRatio || 1;
      if (this.r) {
        canvas.style.width = "" + canvas.width + "px";
        canvas.style.height = "" + canvas.height + "px";
        canvas.width = canvas.width * this.r;
        canvas.height = canvas.height * this.r;
      }
      this.canvas.addEventListener('mousedown', this.canvasMouseDown);
      this.canvas.addEventListener('mousemove', this.canvasMouseMove);
      this.canvas.addEventListener('mouseup', this.canvasMouseUp);
      this.canvas.addEventListener('keyup', this.canvasKeyUp);
      this.canvas.addEventListener('keydown', (function(_this) {
        return function(e) {
          return e.preventDefault();
        };
      })(this));
    }

    UIGraph.prototype.draw = function() {
      var controlPoint, coords, coordsControlPoint, h, point, r, step, t, v, w, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      if (!this.curve) {
        return;
      }
      r = window.devicePixelRatio;
      w = this.canvas.width;
      h = this.canvas.height;
      step = 0.001;
      this.ctx.clearRect(0, 0, w, h);
      this.ctx.strokeStyle = '#D5E6F8';
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.67 * h);
      this.ctx.lineTo(w, 0.67 * h);
      this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.moveTo(0, 0.34 * h);
      this.ctx.lineTo(w, 0.34 * h);
      this.ctx.stroke();
      t = 0;
      this.ctx.beginPath();
      this.ctx.strokeStyle = '#0070FF';
      this.ctx.lineWidth = 2 * r;
      while (t <= 1) {
        v = this.curve(t);
        y = h - ((0.33 + (v * 0.33)) * h);
        if (t === 0) {
          this.ctx.moveTo(t * w, y);
        } else {
          this.ctx.lineTo(t * w, y);
        }
        t += step;
      }
      this.ctx.stroke();
      if (this.points) {
        _ref = this.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          _ref1 = point.cp;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            controlPoint = _ref1[_j];
            this.ctx.beginPath();
            this.ctx.strokeStyle = 'blue';
            this.ctx.lineWidth = 1;
            coords = this.pointCoordinates(point);
            this.ctx.moveTo(coords.x, coords.y);
            coordsControlPoint = this.pointCoordinates(controlPoint);
            this.ctx.lineTo(coordsControlPoint.x, coordsControlPoint.y);
            this.ctx.stroke();
          }
        }
        _ref2 = this.points;
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          point = _ref2[_k];
          this.ctx.beginPath();
          this.ctx.strokeStyle = this.selectedPoint === point ? 'black' : 'blue';
          this.ctx.fillStyle = 'white';
          this.ctx.lineWidth = 2 * r;
          coords = this.pointCoordinates(point);
          this.ctx.arc(coords.x, coords.y, 5 * r, 0, Math.PI * 2, true);
          this.ctx.fill();
          this.ctx.stroke();
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = point.cp;
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              controlPoint = _ref3[_l];
              this.ctx.beginPath();
              this.ctx.strokeStyle = this.selectedPoint === controlPoint ? 'black' : 'blue';
              this.ctx.fillStyle = 'white';
              this.ctx.lineWidth = 1 * r;
              coords = this.pointCoordinates(controlPoint);
              this.ctx.arc(coords.x, coords.y, 3 * r, 0, Math.PI * 2, true);
              this.ctx.fill();
              _results1.push(this.ctx.stroke());
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }
    };

    UIGraph.prototype.locationFromEvent = function(e) {
      return {
        x: e.layerX,
        y: e.layerY
      };
    };

    UIGraph.prototype.isLocationAroundCenter = function(location, center, size) {
      var r;
      r = window.devicePixelRatio;
      center = {
        x: center.x / r,
        y: center.y / r
      };
      return (location.x >= center.x - size / 2) && (location.x <= center.x + size / 2) && (location.y >= center.y - size / 2) && (location.y <= center.y + size / 2);
    };

    UIGraph.prototype.pointFromLocation = function(location) {
      var controlPoint, point, _i, _j, _len, _len1, _ref, _ref1;
      if ((this.points == null) || this.points.length < 2) {
        return null;
      }
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        if (point !== this.points[0]) {
          if (this.isLocationAroundCenter(location, this.pointCoordinates(point), 14)) {
            return point;
          }
        }
        _ref1 = point.cp;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          controlPoint = _ref1[_j];
          if (this.isLocationAroundCenter(location, this.pointCoordinates(controlPoint), 10)) {
            return controlPoint;
          }
        }
      }
      return null;
    };

    UIGraph.prototype.canvasMouseDown = function(e) {
      var converted, location;
      if (!this.editable) {
        return;
      }
      location = this.locationFromEvent(e);
      this.selectedPoint = this.pointFromLocation(location);
      if (!this.selectedPoint) {
        converted = this.convertFromCoordinates(location);
        this.selectedPoint = {
          x: converted.x,
          y: converted.y,
          cp: [
            {
              x: converted.x - 0.1,
              y: converted.y
            }, {
              x: converted.x + 0.1,
              y: converted.y
            }
          ]
        };
        this.insertPoint(this.selectedPoint);
      }
      if (typeof this.pointsChanged === "function") {
        this.pointsChanged();
      }
      this.draw();
      return this.dragging = true;
    };

    UIGraph.prototype.canvasMouseMove = function(e) {
      var controlPoint, location, point, _i, _len, _ref;
      if (!this.editable) {
        return;
      }
      if (!this.selectedPoint) {
        return;
      }
      if (!this.dragging) {
        return;
      }
      location = this.locationFromEvent(e);
      point = this.convertFromCoordinates(location);
      if (this.selectedPoint === this.points[this.points.length - 1]) {
        point.x = 1;
        point.y = Math.min(1, Math.max(0, Math.round(point.y)));
      }
      if (this.selectedPoint.cp) {
        _ref = this.selectedPoint.cp;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          controlPoint = _ref[_i];
          controlPoint.x = roundf(controlPoint.x + point.x - this.selectedPoint.x, 3);
          controlPoint.y = roundf(controlPoint.y + point.y - this.selectedPoint.y, 3);
        }
      }
      this.selectedPoint.x = point.x;
      this.selectedPoint.y = point.y;
      if (typeof this.pointsChanged === "function") {
        this.pointsChanged();
      }
      return this.draw();
    };

    UIGraph.prototype.canvasMouseUp = function(e) {
      if (!this.editable) {
        return;
      }
      this.dragging = false;
      return typeof this.pointsChanged === "function" ? this.pointsChanged() : void 0;
    };

    UIGraph.prototype.canvasKeyUp = function(e) {
      if (!this.editable) {
        return;
      }
      if (!this.selectedPoint) {
        return;
      }
      if (e.keyCode === 8) {
        if (!this.selectedPoint.cp) {
          return;
        }
        if (this.selectedPoint === this.points[0] || this.selectedPoint === this.points[this.points.length - 1]) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        this.points.splice(this.points.indexOf(this.selectedPoint), 1);
        this.selectedPoint = null;
        return typeof this.pointsChanged === "function" ? this.pointsChanged() : void 0;
      }
    };

    UIGraph.prototype.pointCoordinates = function(point) {
      var h, w;
      w = this.canvas.width;
      h = this.canvas.height;
      return {
        x: point.x * w,
        y: (0.67 * h) - (point.y * 0.33 * h)
      };
    };

    UIGraph.prototype.convertFromCoordinates = function(location) {
      var h, r, w;
      r = window.devicePixelRatio;
      w = this.canvas.width;
      h = this.canvas.height;
      return {
        x: roundf(location.x / w * r, 3),
        y: roundf(((0.67 * h) - (location.y * r)) / (0.33 * h), 3)
      };
    };

    UIGraph.prototype.insertPoint = function(toInsertPoint) {
      var i, index, point, _ref;
      if (!this.points) {
        return;
      }
      index = 0;
      _ref = this.points;
      for (i in _ref) {
        point = _ref[i];
        if (point.x >= toInsertPoint.x) {
          index = i;
          break;
        }
      }
      return this.points.splice(index, 0, toInsertPoint);
    };

    return UIGraph;

  })();

  UIProperty = (function() {
    function UIProperty(options) {
      this.options = options != null ? options : {};
      this.setValue = __bind(this.setValue, this);
      this.el = document.createElement('div');
      this.label = document.createElement('label');
      this.label.innerHTML = this.options.property;
      this.valueEl = document.createElement('div');
      this.valueEl.classList.add('value');
      this.valueEl.classList.add(options.property);
      this.el.appendChild(this.label);
      this.el.appendChild(this.valueEl);
      this.valueEl.innerHTML = this.options.value;
    }

    UIProperty.prototype.setValue = function(value) {
      this.options.value = value;
      return this.valueEl.innerHTML = this.options.value;
    };

    return UIProperty;

  })();

  UISlider = (function() {
    function UISlider(options) {
      var _base, _base1;
      this.options = options != null ? options : {};
      this._windowMouseUp = __bind(this._windowMouseUp, this);
      this._windowMouseMove = __bind(this._windowMouseMove, this);
      this._controlMouseDown = __bind(this._controlMouseDown, this);
      this._sliderMouseDown = __bind(this._sliderMouseDown, this);
      this._updateLeftFromValue = __bind(this._updateLeftFromValue, this);
      this.value = __bind(this.value, this);
      if ((_base = this.options).min == null) {
        _base.min = 0;
      }
      if ((_base1 = this.options).max == null) {
        _base1.max = 1000;
      }
      if (this.options.value === void 0) {
        this.options.value = 10;
      }
      this.width = 205 - 11;
      this.el = document.createElement('div');
      this.label = document.createElement('label');
      this.label.innerHTML = this.options.property;
      this.valueEl = document.createElement('div');
      this.valueEl.classList.add('value');
      this.valueEl.classList.add(options.property);
      this.slider = document.createElement('div');
      this.slider.classList.add('slider');
      this.slider.classList.add(options.property);
      this.bar = document.createElement('div');
      this.bar.classList.add('bar');
      this.control = document.createElement('div');
      this.control.classList.add('control');
      this.slider.appendChild(this.bar);
      this.slider.appendChild(this.control);
      this.el.appendChild(this.label);
      this.el.appendChild(this.valueEl);
      this.el.appendChild(this.slider);
      this.valueEl.innerHTML = this.options.value;
      this._updateLeftFromValue();
      this.slider.addEventListener('mousedown', this._sliderMouseDown);
      this.control.addEventListener('mousedown', this._controlMouseDown);
    }

    UISlider.prototype.value = function() {
      return this.options.value;
    };

    UISlider.prototype._updateLeftFromValue = function() {
      return this.control.style.left = (this.options.value - this.options.min) / (this.options.max - this.options.min) * this.width + "px";
    };

    UISlider.prototype._sliderMouseDown = function(e) {
      var layerX;
      layerX = e.layerX;
      this.options.value = Math.round(layerX / (this.width + 11) * (this.options.max - this.options.min) + this.options.min);
      this.valueEl.innerHTML = this.options.value;
      if (typeof this.onUpdate === "function") {
        this.onUpdate();
      }
      this.control.style.left = Math.round(layerX / (this.width + 11) * this.width) + "px";
      return this._controlMouseDown(e);
    };

    UISlider.prototype._controlMouseDown = function(e) {
      this.dragging = true;
      this.startPoint = [e.pageX, e.pageY];
      this.startLeft = parseInt(this.control.style.left || 0);
      this.control.classList.add('highlighted');
      window.addEventListener('mousemove', this._windowMouseMove);
      window.addEventListener('mouseup', this._windowMouseUp);
      return e.stopPropagation();
    };

    UISlider.prototype._windowMouseMove = function(e) {
      var dX, newLeft;
      if (!this.dragging) {
        return;
      }
      dX = e.pageX - this.startPoint[0];
      newLeft = this.startLeft + dX;
      if (newLeft > this.width) {
        newLeft = this.width;
      } else if (newLeft < 0) {
        newLeft = 0;
      }
      this.options.value = Math.round(newLeft / this.width * (this.options.max - this.options.min) + this.options.min);
      this.valueEl.innerHTML = this.options.value;
      if (typeof this.onUpdate === "function") {
        this.onUpdate();
      }
      return this.control.style.left = newLeft + "px";
    };

    UISlider.prototype._windowMouseUp = function(e) {
      this.dragging = false;
      this.control.classList.remove('highlighted');
      window.removeEventListener('mousemove', this._windowMouseMove);
      return window.removeEventListener('mouseup', this._windowMouseUp);
    };

    return UISlider;

  })();

  Editor = (function() {
    function Editor(options) {
      var canvasSize, graphEl, r, settingsEl, spanIndex0, spanIndex1;
      this.options = options != null ? options : {};
      this.createCircle = __bind(this.createCircle, this);
      this.startAnimation = __bind(this.startAnimation, this);
      this.startAnimationDelayed = __bind(this.startAnimationDelayed, this);
      this.code = __bind(this.code, this);
      this.onPointsChanged = __bind(this.onPointsChanged, this);
      this.redraw = __bind(this.redraw, this);
      this.update = __bind(this.update, this);
      this.fillSettings = __bind(this.fillSettings, this);
      this.selectDidChange = __bind(this.selectDidChange, this);
      this.fillSelect = __bind(this.fillSelect, this);
      this.width = 580;
      this.height = this.width - 234;
      this.duration = 1000;
      this.el = document.createElement('div');
      this.el.id = 'editor';
      this.el.addEventListener('click', function(e) {
        return e.stopPropagation();
      });
      graphEl = document.createElement('div');
      graphEl.className = 'graph';
      this.canvas = document.createElement('canvas');
      this.canvas.setAttribute('tabIndex', '0');
      r = window.devicePixelRatio || 1;
      canvasSize = this.width - 234;
      this.canvas.width = "" + canvasSize;
      this.canvas.height = "" + canvasSize;
      spanIndex0 = document.createElement('span');
      spanIndex0.className = 'index0';
      spanIndex0.innerHTML = '0';
      spanIndex1 = document.createElement('span');
      spanIndex1.className = 'index1';
      spanIndex1.innerHTML = '1';
      graphEl.appendChild(this.canvas);
      graphEl.appendChild(spanIndex0);
      graphEl.appendChild(spanIndex1);
      this.el.appendChild(graphEl);
      settingsEl = document.createElement('div');
      settingsEl.className = 'settings';
      this.select = document.createElement('select');
      this.select.className = 'dynamics';
      this.optionsEl = document.createElement('div');
      this.optionsEl.className = 'options';
      settingsEl.appendChild(this.select);
      settingsEl.appendChild(this.optionsEl);
      this.el.appendChild(settingsEl);
      this.currentCircle = null;
      this.select.addEventListener('change', this.selectDidChange);
      this.graph = new UIGraph(this.canvas);
      this.graph.pointsChanged = this.onPointsChanged;
      this.sliders = [];
      this.properties = [];
      this.el.style.width = this.width + 'px';
      this.el.style.height = this.height + 'px';
      this.fillSelect();
      this.selectDidChange();
    }

    Editor.prototype.fillSelect = function() {
      var k, option, sortedDynamicsKeys, _i, _len, _results;
      sortedDynamicsKeys = ['spring', 'bounce', 'forceWithGravity', 'gravity', 'bezier', 'easeInOut', 'easeIn', 'easeOut', 'linear'];
      _results = [];
      for (_i = 0, _len = sortedDynamicsKeys.length; _i < _len; _i++) {
        k = sortedDynamicsKeys[_i];
        option = document.createElement('option');
        option.innerHTML = "dynamics." + k;
        option.value = k;
        _results.push(this.select.appendChild(option));
      }
      return _results;
    };

    Editor.prototype.selectDidChange = function() {
      var k, name, v, _ref;
      this.select.blur();
      name = this.select.options[this.select.selectedIndex].value;
      if (name === "bezier") {
        this.graph.points = [
          {
            x: 0,
            y: 0,
            cp: [
              {
                x: 0.1,
                y: 0
              }
            ]
          }, {
            x: 1,
            y: 1,
            cp: [
              {
                x: 0.9,
                y: 1
              }
            ]
          }
        ];
        this.graph.editable = true;
      } else {
        this.graph.points = null;
        this.graph.editable = false;
      }
      this.curveName = "dynamics." + name;
      this.curve = eval(this.curveName);
      this.values = {};
      _ref = this.curve.defaults;
      for (k in _ref) {
        v = _ref[k];
        this.values[k] = v;
      }
      this.fillSettings();
      return this.update();
    };

    Editor.prototype.fillSettings = function() {
      var k, slider, v, _ref, _results;
      this.optionsEl.innerHTML = '';
      this.sliders = [];
      slider = new UISlider({
        min: 100,
        max: 5000,
        value: this.duration,
        property: "duration"
      });
      slider.onUpdate = this.update;
      this.optionsEl.appendChild(slider.el);
      this.sliders.push(slider);
      _ref = this.curve.defaults;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        slider = new UISlider({
          min: v === 0 ? 0 : 1,
          max: 1000,
          value: this.values[k],
          property: k
        });
        slider.onUpdate = this.update;
        this.optionsEl.appendChild(slider.el);
        _results.push(this.sliders.push(slider));
      }
      return _results;
    };

    Editor.prototype.update = function() {
      var points, slider, _i, _len, _ref, _ref1;
      _ref = this.sliders;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slider = _ref[_i];
        if (slider.options.property === 'duration') {
          this.duration = slider.value();
        } else {
          this.values[slider.options.property] = slider.value();
        }
      }
      if (this.graph.points != null) {
        points = this.graph.points.slice();
        points = points.sort(function(a, b) {
          if (a.x < b.x) {
            return -1;
          }
          return 1;
        });
        this.values.points = points;
      } else {
        delete this.values.points;
      }
      this.redraw();
      if ((_ref1 = this.options.onChange) != null) {
        _ref1.call(this);
      }
      return this.startAnimationDelayed();
    };

    Editor.prototype.redraw = function() {
      this.graph.curve = this.curve(this.values);
      return this.graph.draw();
    };

    Editor.prototype.onPointsChanged = function() {
      return this.update();
    };

    Editor.prototype.code = function(html) {
      var k, props, strong1, strong2, v, _ref, _ref1, _ref2;
      if (html == null) {
        html = false;
      }
      strong1 = html ? "<strong>" : "";
      strong2 = html ? "</strong>" : "";
      props = "";
      if (this.duration !== 1000) {
        props += ",\n  " + strong1 + "duration" + strong2 + ": " + this.duration;
      }
      _ref = this.values;
      for (k in _ref) {
        v = _ref[k];
        if (k === "points") {
          v = JSON.stringify(v);
        }
        if (v !== ((_ref1 = this.curve) != null ? (_ref2 = _ref1.defaults) != null ? _ref2[k] : void 0 : void 0)) {
          props += ",\n  " + strong1 + k + strong2 + ": " + v;
        }
      }
      return "" + strong1 + "dynamics.animate" + strong2 + "(document.querySelector('.circle'), {\n  " + strong1 + "translateX" + strong2 + ": 350\n}, {\n  " + strong1 + "type" + strong2 + ": " + this.curveName + props + "\n})";
    };

    Editor.prototype.startAnimationDelayed = function() {
      dynamics.clearTimeout(this.delayedAnimation);
      return this.delayedAnimation = dynamics.setTimeout(this.startAnimation, 100);
    };

    Editor.prototype.startAnimation = function() {
      var circle, initialForce, oldCircle, options, timeout;
      timeout = 0;
      if (this.circle != null) {
        oldCircle = this.circle;
        this.circle = null;
        dynamics.animate(oldCircle, {
          opacity: 0
        }, {
          type: dynamics.easeInOut,
          duration: 100,
          complete: (function(_this) {
            return function() {
              var demo;
              demo = document.querySelector('.demo');
              if (oldCircle.parentNode != null) {
                return demo.removeChild(oldCircle);
              }
            };
          })(this)
        });
      }
      this.circle = circle = this.createCircle();
      clearTimeout(this.restartAnimationTimeout);
      initialForce = this.curve(this.values).initialForce;
      options = merge(this.values, {
        type: this.curve,
        duration: this.duration,
        delay: 250,
        complete: (function(_this) {
          return function() {
            var wasCircle;
            wasCircle = _this.circle;
            if (_this.circle !== circle) {
              return;
            }
            _this.circle = null;
            _this.restartAnimationTimeout = dynamics.setTimeout(_this.startAnimation, 300);
            return dynamics.animate(circle, {
              translateX: initialForce ? 0 : 350,
              scale: 0.01
            }, {
              type: dynamics.easeInOut,
              duration: 100,
              delay: 100,
              complete: function() {
                var demo;
                demo = document.querySelector('.demo');
                if (circle.parentNode != null) {
                  return demo.removeChild(circle);
                }
              }
            });
          };
        })(this)
      });
      return dynamics.animate(circle, {
        translateX: 350
      }, options);
    };

    Editor.prototype.createCircle = function() {
      var circle, demo;
      demo = document.querySelector('.demo');
      circle = document.createElement('div');
      circle.className = 'circle';
      dynamics.css(circle, {
        scale: 0.01
      });
      demo.appendChild(circle);
      dynamics.animate(circle, {
        scale: 1
      }, {
        type: dynamics.spring,
        friction: 300,
        duration: 800
      });
      return circle;
    };

    return Editor;

  })();

  dynamics.Editor = Editor;

}).call(this);
